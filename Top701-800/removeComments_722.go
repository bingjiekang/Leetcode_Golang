package main

// 给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第 i 行源码。 这表示每行源码由 '\n' 分隔。
// 在 C++ 中有两种注释风格，行内注释和块注释。
// 字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。
// 字符串/* 表示一个块注释，它表示直到下一个（非重叠）出现的*/之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。
// 第一个有效注释优先于其他注释。
// 如果字符串//出现在块注释中会被忽略。
// 同样，如果字符串/*出现在行或块注释中也会被忽略。
// 如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。
// 样例中没有控制字符，单引号或双引号字符。
// 比如，source = "string s = "/* Not a comment. */";" 不会出现在测试样例里。
// 此外，没有其他内容（如定义或宏）会干扰注释。
// 我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。
// 最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。
// 从源代码中删除注释后，需要以相同的格式返回源代码。

// 两大类：在块内和不在块内，用bloak进行标记
// 注意: 1. //所在行后面的全部直接删去  2. 当出现/*且不在块内时才开始标记,当出现*/且在块内时取消标记,同时全部对序号+1防止重复遍历 3. 只有当得到的不为空切不在块内时才加入sult,否则继续添加后面元素
func removeComments(source []string) (sult []string) {
	// 定义bloak用来记录是否在标注内
	var bloak bool = false
	// 用来存储每一次要加入的字符数组
	temp := []byte{}
	// 遍历这个资源
	for _, v := range source {
		// 获取长度
		length := len(v)
		// 用来遍历每个字符
		for i := 0; i < length; i++ {
			// 当检查到// 时直接结束这一行的遍历,注意需要不在块内切i+1不能超过最大下标,防止越界
			if i < length-1 && v[i] == '/' && v[i+1] == '/' && bloak == false {
				break
			} else if i < length-1 && !bloak && v[i] == '/' && v[i+1] == '*' { // 当检查到/* bloak进行标记，直到*/进行解除,注意此时的bloak取值
				i++
				bloak = true
			} else if i < length-1 && bloak && v[i] == '*' && v[i+1] == '/' {
				i++
				bloak = false
			} else { // 不在块内进行加入字符
				if !bloak {
					temp = append(temp, v[i])
				}
			}
		}
		// 获取每一次待加入的字符串,当不为空且不在块内时加入sult,加入后清除内部元素
		ltmp := string(temp)
		if ltmp != "" && !bloak {
			sult = append(sult, ltmp)
			temp = []byte{}
		}

	}
	return
}
