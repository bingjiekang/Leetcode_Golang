package main

// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

// 示例 ：
// 输入：nums = [1,2,3]
// 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
// 当求2的n幂次方时,可以使用1<<左移n 既可得到结果
// 解析:使用位运算,由于1-n的二进制位对应的就是每个子集出现的位置,则可以对每个数进行向右移动,移动的位数为,数组的下标,如果此时与1后仍大于0,证明这个位数为1,如果与1后为0则证明这位为0,不用选取
func subsets(nums []int) (sult [][]int) {
	// 获取nums的长度，用来确定对应二进制的大小
	length := len(nums)
	// 遍历从0到2的length-1得到，对应二进制的所有可能
	for nm := 0; nm < (1 << length); nm++ {
		// 用来临时存储每个子集
		var temp []int
		// 遍历每个nums的元素，用来得到需要右移的位数和对应的每位数据
		for i, v := range nums {
			// >> 右移 &1 与1 用来获取对应位 为1的数 将对应位数的数据，提取出来加到临时的temp数组中
			if nm>>i&1 > 0 {
				temp = append(temp, v)
			}
		}
		// 将每个子集数组加入到结果中
		sult = append(sult, temp)
	}
	return
}
