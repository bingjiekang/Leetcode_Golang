package main

// 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
// 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
// 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
// 网格中的障碍物和空位置分别用 1 和 0 来表示。

// 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
// 输出：2
// 解释：3x3 网格的正中间有一个障碍物。
// 从左上角到右下角一共有 2 条不同的路径：
// 1. 向右 -> 向右 -> 向下 -> 向下
// 2. 向下 -> 向下 -> 向右 -> 向右

// 使用dp动态规划，由于只能向右或者向下
// 则判断对应下标是否为1，如果为1则更新此下标位0，若为第一行则此后右侧都为0，用tm标记第一行已经出现了障碍，若为第一列则此后第一列都为0用tn标记第一列已经出现了障碍，如果不为第一行也不为第一列则直接更新为1即可
// 对应下标为0，则更新此下标对应值为temp[i-1][j]+temp[i][j-1]的值
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
	// 赋值，用temp变量接收原切片
	temp := obstacleGrid
	// tm为用来标记行是否出现了障碍，tn用来标记列是否出现了障碍
	var tm, tn bool = true, true
	// m,n用来获取该切片的长度
	m, n := len(temp), len(temp[0])
	// 遍历这个数组
	for i, v := range obstacleGrid {
		for j, k := range v {
			// 如果在第一行或者第一列则进入
			if i == 0 || j == 0 {
				if (i == 0 || j == 0) && k == 1 { // 如果为第一行或者第一列，且出现了障碍
					temp[i][j] = 0        // 赋值该下标对应值为0
					if i == 0 && j == 0 { // 如果i，j都为0,则代表初始位置为0，更新tm,tn标志为行列都出现了障碍
						tm = false
						tn = false
					} else if i == 0 { // 如果i为0，则证明行出现了障碍，更新tm标记为0
						tm = false
					} else if j == 0 { // 如果j为0，则证明列出现了障碍，更新tn标记为0
						tn = false
					}
				} else if (i == 0 && tm) || (j == 0 && tn) { // 如果第一行或列没有出现障碍，则标记对应值为1
					temp[i][j] = 1
				}
			} else { // 不在第一行第一列
				if temp[i][j] == 1 { // 如果出现障碍则直接更新为0
					temp[i][j] = 0
				} else { // 否则计算新的值，更新此下标
					temp[i][j] = temp[i-1][j] + temp[i][j-1]
				}
			}
		}
	}
	// 返回右下角的值即可
	return temp[m-1][n-1]
}
