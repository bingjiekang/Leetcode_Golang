package face17

import (
	"fmt"
)

// 两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常“稀疏”，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。

// 输入为一个二维数组 docs，docs[i] 表示 id 为 i 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 {id1},{id2}: {similarity}，其中 id1 为两个文档中较小的 id，similarity 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。

// 输入:
// [
//   [14, 15, 100, 9, 3],
//   [32, 1, 9, 3, 5],
//   [15, 29, 2, 6, 8, 7],
//   [7, 10]
// ]
// 输出:
// [
//   "0,1: 0.2500",
//   "0,2: 0.1000",
//   "2,3: 0.1429"
// ]

// 解析:
// 1.先遍历所有文档的所有单词，mp1[word]返回数组，表示包含有单词word的文档id
// 2.生成mp1需要O(DW)复杂度，D表示文档数量，W表示每个文档的单词数（粗略认为W相等）。
// 3.根据mp1我们就可以判断哪两个文档会相交，只对相交的文档进行相似度计算。即使相似性的计算这块是个暴力法，速度也不会很慢，因为题目说了相交是稀疏的，只有很少的文档有会相交。
// 4.知道哪两个文档会相交后，分别排序两个文档内的单词，然后双指针找出两个文档相交元素，进一步的计算出这两个文档的相似度。

func computeSimilarities(docs [][]int) (sult []string) {
	// length存储有多少个数组
	length := len(docs)
	// 用map型数组存储每组数组对应的组数数组
	curd := map[int][]int{}
	// lt存储对应下标i,j交集的个数
	lt := [][]int{}
	// 对lt内部的数组进行遍历声明和初始化
	for i := 0; i < length; i++ {
		lt = append(lt, make([]int, length))
	}
	// 遍历docs里的每个数组,获得每个数在对应组里出现的次数
	for i, v := range docs {
		for _, w := range v {
			// 判断数w是否已经在map1里
			_, ok := curd[w]
			if !ok { // 如果不在则声明一个
				curd[w] = []int{i}
			} else { // 如果存在则遍历这个数存储不同组号的数组
				for _, tm := range curd[w] {
					// 对已经存在的组的下标和当前遍历到的组的下标结合即为对应i,j下标
					lt[tm][i]++
				}
				// 将当前组的下标加到,已经存在的数对应的数组里
				curd[w] = append(curd[w], i)
			}
		}
	}

	// 遍历每个数组获取对应数组下标的长度 相加-交集即为并集,想除并转换加入即可
	for i := 0; i < length-1; i++ {
		for j := i + 1; j < length; j++ {
			if lt[i][j] > 0 { // 舍弃等于0的数
				// 求对应并集
				ad := len(docs[i]) + len(docs[j]) - lt[i][j]
				// 求结果,由于sprintf为四舍六入五成双,前面小数点后有四位是偶数,则大于等于6才入1,加上1e-9保持精度
				ku := float64(lt[i][j])/float64(ad) + 1e-9
				tsu := fmt.Sprintf("%d,%d: %.4f", i, j, ku)
				// 加入结果即可
				sult = append(sult, tsu)
			}

		}
	}
	return
}
