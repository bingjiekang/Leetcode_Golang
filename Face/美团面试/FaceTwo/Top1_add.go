// 1. 小美的加法 easy
// 小美有一个长度为 n 的数组，她想将这个数组进行求和，即 sum=a1+a2+a3+....an
// 小美可以使用一次魔法（也可以不使用），将其中一个加号变成乘号，使得 sum 最大。
// 求出最大的 sum 。

// 时间限制：C/C++ 1秒，其他语言2秒
// 空间限制：C/C++ 256M，其他语言512M
// 输入描述：
// 第一行输入一个整数 n 。
// 第二行输入 n 个整数表示数组 a 。
// 1 <= n <= 10^5
// 1 <= ai <= 10^9

// 输出描述：
// 输出一个整数表示答案。
// 示例1
// 输入例子：
// 6
// 1 1 4 5 1 4
// 输出例子：
// 27
// 例子说明：
// 小美可以将 4 和 5 之间的加号改成乘号。
// 1 + 1 + 4 * 5 + 1 + 4 = 27

// 解析:通过判断变化当前乘法和之前的变换过的进行比较,如果大于之前变化过的则更新,否则,则正常的进行加法操作,保证了只有一次变化,其他数字出现的次数都相同

package main

import (
	"fmt"
)

func main() {
	// 用来获得并存储输入的内容
	var n, m int
	lt := []int{}
	fmt.Scanf("%d", &n)
	for i := 0; i < n; i++ {
		fmt.Scanf("%d", &m)
		lt = append(lt, m)
	}
	// ad是正常的加法,从第一个到最后一个,pd是存在一个加法变乘法后的数
	ad, pd := lt[0], lt[0]
	for i := 1; i < n; i++ {
		// temp为 当前值和前一值相乘,其他都是相加 得到的结果
		temp := ad - lt[i-1] + lt[i-1]*lt[i]
		// ad是正常加法得到的结果
		ad += lt[i]
		// 如果当前值和前一值相乘得到的结果大于 之前变换加法后的结果,则更新pd
		if temp > pd {
			pd = temp
		} else { // 否则 则对pd进行正常数相加
			pd += lt[i]
		}
	}
	// 输出pd即为结果
	fmt.Println(pd)

}
